<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>超級 Kawaii 跳躍</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background-color: #87CEEB;
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      overflow: hidden;
      touch-action: manipulation;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 800px;
      height: 400px;
      margin: 0 auto;
    }
    
    #gameCanvas {
      background-color: #87CEEB;
      display: block;
      width: 100%;
      height: 100%;
      border: 4px solid #5D4037;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
    }
    
    #uiContainer {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 800px;
      padding: 10px;
      color: white;
      font-size: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    #mobileControls {
      display: none;
      width: 100%;
      max-width: 800px;
      justify-content: space-between;
      padding: 20px;
    }
    
    .mobile-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.7);
      border: 3px solid #5D4037;
      font-size: 24px;
      font-weight: bold;
      color: #5D4037;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 10;
    }
    
    #gameOverScreen {
      display: none;
    }
    
    .screen-title {
      font-size: 48px;
      margin-bottom: 20px;
      color: #FFD700;
      text-shadow: 3px 3px 0 #FF4500;
    }
    
    .screen-btn {
      padding: 15px 30px;
      background-color: #FF4500;
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 20px;
      margin: 10px;
      cursor: pointer;
      box-shadow: 0 5px 0 #8B0000;
      transition: all 0.1s;
    }
    
    .screen-btn:active {
      transform: translateY(5px);
      box-shadow: none;
    }
    
    @media (max-width: 768px) {
      #mobileControls {
        display: flex;
      }
      
      #uiContainer {
        font-size: 16px;
      }
      
      .screen-title {
        font-size: 36px;
      }
    }
  </style>
</head>
<body>
  <div id="uiContainer">
    <div id="scoreDisplay">分數: 0</div>
    <div id="highScoreDisplay">最高分: 0</div>
    <div id="livesDisplay">生命: 3</div>
  </div>
  
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <div id="startScreen">
      <h1 class="screen-title">超級 Kawaii 跳躍</h1>
      <p>收集星星！避開敵人！</p>
      <button class="screen-btn" id="startBtn">開始遊戲</button>
    </div>
    
    <div id="gameOverScreen">
      <h1 class="screen-title">遊戲結束</h1>
      <p id="finalScore">你的分數: 0</p>
      <button class="screen-btn" id="restartBtn">再玩一次</button>
    </div>
  </div>
  
  <div id="mobileControls">
    <div class="mobile-btn" id="leftBtn">←</div>
    <div class="mobile-btn" id="jumpBtn">跳</div>
  </div>

  <script>
    // 遊戲設定
    const config = {
      width: 800,
      height: 400,
      localStorageKey: 'kawaiiJumpHighScore',
      gravity: 0.5,
      playerSpeed: 5,
      jumpPower: 12,
      enemySpeed: 4,
      starPoints: 10,
      coinPoints: 5
    };
    
    // 遊戲元素
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const finalScore = document.getElementById('finalScore');
    const leftBtn = document.getElementById('leftBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    
    // 遊戲狀態
    let gameState = {
      score: 0,
      highScore: localStorage.getItem(config.localStorageKey) || 0,
      lives: 3,
      isRunning: false,
      keys: {
        ArrowLeft: false,
        ArrowRight: false,
        Space: false
      }
    };
    
    // 遊戲物件
    let player, enemies = [], stars = [], platforms = [], coins = [];
    
    // 圖片資源
    const images = {
      player: new Image(),
      enemy: new Image(),
      star: new Image(),
      platform: new Image(),
      coin: new Image(),
      background: new Image()
    };
    
    // 載入圖片
    images.player.src = 'player.jpg';    // 你的玩家角色圖片
    images.enemy.src = 'enemy.jpg';      // 你的敵人圖片
    images.star.src = 'star.jpg';        // 星星圖片
    images.platform.src = 'platform.jpg';// 平台圖片
    images.coin.src = 'coin.jpg';       // 金幣圖片
    images.background.src = 'background.jpg'; // 背景圖片
    
    // 初始化遊戲
    function initGame() {
      // 設定畫布大小
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // 載入最高分
      highScoreDisplay.textContent = `最高分: ${gameState.highScore}`;
      
      // 事件監聽器
      setupEventListeners();
      
      // 開始畫面
      startBtn.addEventListener('click', startGame);
      restartBtn.addEventListener('click', startGame);
    }
    
    // 調整畫布大小
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      
      // 更新遊戲設定中的高度和寬度
      config.width = canvas.width;
      config.height = canvas.height;
      
      if (gameState.isRunning) {
        draw();
      }
    }
    
    // 設定事件監聽器
    function setupEventListeners() {
      // 鍵盤控制
      document.addEventListener('keydown', (e) => {
        if (['ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
          gameState.keys[e.code] = true;
          e.preventDefault();
        }
      });
      
      document.addEventListener('keyup', (e) => {
        if (['ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
          gameState.keys[e.code] = false;
          e.preventDefault();
        }
      });
      
      // 手機觸控控制
      leftBtn.addEventListener('touchstart', (e) => {
        gameState.keys.ArrowLeft = true;
        e.preventDefault();
      });
      
      leftBtn.addEventListener('touchend', (e) => {
        gameState.keys.ArrowLeft = false;
        e.preventDefault();
      });
      
      jumpBtn.addEventListener('touchstart', (e) => {
        gameState.keys.Space = true;
        e.preventDefault();
      });
      
      jumpBtn.addEventListener('touchend', (e) => {
        gameState.keys.Space = false;
        e.preventDefault();
      });
      
      // 點擊按鈕控制 (為非觸控設備)
      leftBtn.addEventListener('mousedown', () => gameState.keys.ArrowLeft = true);
      leftBtn.addEventListener('mouseup', () => gameState.keys.ArrowLeft = false);
      leftBtn.addEventListener('mouseleave', () => gameState.keys.ArrowLeft = false);
      
      jumpBtn.addEventListener('mousedown', () => gameState.keys.Space = true);
      jumpBtn.addEventListener('mouseup', () => gameState.keys.Space = false);
      jumpBtn.addEventListener('mouseleave', () => gameState.keys.Space = false);
    }
    
    // 開始遊戲
    function startGame() {
      // 重置遊戲狀態
      gameState.score = 0;
      gameState.lives = 3;
      gameState.isRunning = true;
      
      // 隱藏開始和結束畫面
      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';
      
      // 更新UI
      updateUI();
      
      // 初始化遊戲物件
      initGameObjects();
      
      // 開始遊戲循環
      gameLoop();
    }
    
    // 初始化遊戲物件
    function initGameObjects() {
      // 玩家
      player = {
        x: 100,
        y: config.height - 150,
        width: 50,
        height: 70,
        velX: 0,
        velY: 0,
        isJumping: false,
        direction: 'right'
      };
      
      // 平台
      platforms = [
        { x: 0, y: config.height - 50, width: config.width, height: 50 },
        { x: 200, y: 300, width: 150, height: 20 },
        { x: 400, y: 250, width: 150, height: 20 },
        { x: 600, y: 200, width: 150, height: 20 }
      ];
      
      // 敵人
      enemies = [
        { x: 500, y: config.height - 100, width: 50, height: 50, speed: -2 },
        { x: 800, y: 250, width: 50, height: 50, speed: -3 }
      ];
      
      // 星星
      stars = [
        { x: 250, y: 260, width: 30, height: 30, collected: false },
        { x: 450, y: 210, width: 30, height: 30, collected: false },
        { x: 650, y: 160, width: 30, height: 30, collected: false }
      ];
      
      // 金幣
      coins = [];
      for (let i = 0; i < 10; i++) {
        coins.push({
          x: Math.random() * (config.width - 30),
          y: Math.random() * (config.height - 100),
          width: 20,
          height: 20,
          collected: false
        });
      }
    }
    
    // 遊戲循環
    function gameLoop() {
      if (!gameState.isRunning) return;
      
      update();
      draw();
      
      requestAnimationFrame(gameLoop);
    }
    
    // 更新遊戲狀態
    function update() {
      // 玩家移動
      if (gameState.keys.ArrowLeft) {
        player.velX = -config.playerSpeed;
        player.direction = 'left';
      } else if (gameState.keys.ArrowRight) {
        player.velX = config.playerSpeed;
        player.direction = 'right';
      } else {
        player.velX = 0;
      }
      
      // 跳躍
      if (gameState.keys.Space && !player.isJumping) {
        player.velY = -config.jumpPower;
        player.isJumping = true;
      }
      
      // 應用重力
      player.velY += config.gravity;
      
      // 更新玩家位置
      player.x += player.velX;
      player.y += player.velY;
      
      // 邊界檢查
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > config.width) player.x = config.width - player.width;
      
      // 平台碰撞檢測
      let onPlatform = false;
      platforms.forEach(platform => {
        if (
          player.x + player.width > platform.x &&
          player.x < platform.x + platform.width &&
          player.y + player.height >= platform.y &&
          player.y + player.height <= platform.y + platform.height / 2 &&
          player.velY > 0
        ) {
          player.y = platform.y - player.height;
          player.velY = 0;
          player.isJumping = false;
          onPlatform = true;
        }
      });
      
      // 如果不在平台上，則標記為跳躍狀態
      if (!onPlatform && player.velY >= 0) {
        player.isJumping = true;
      }
      
      // 敵人移動和碰撞檢測
      enemies.forEach(enemy => {
        enemy.x += enemy.speed;
        
        // 敵人邊界檢查
        if (enemy.x + enemy.width < 0) {
          enemy.x = config.width;
        } else if (enemy.x > config.width) {
          enemy.x = -enemy.width;
        }
        
        // 玩家與敵人碰撞
        if (checkCollision(player, enemy)) {
          playerHit();
        }
      });
      
      // 星星收集
      stars.forEach(star => {
        if (!star.collected && checkCollision(player, star)) {
          star.collected = true;
          gameState.score += config.starPoints;
          updateUI();
        }
      });
      
      // 金幣收集
      coins.forEach(coin => {
        if (!coin.collected && checkCollision(player, coin)) {
          coin.collected = true;
          gameState.score += config.coinPoints;
          updateUI();
        }
      });
      
      // 檢查是否掉落畫面底部
      if (player.y > config.height) {
        playerHit();
      }
    }
    
    // 碰撞檢測
    function checkCollision(obj1, obj2) {
      return (
        obj1.x < obj2.x + obj2.width &&
        obj1.x + obj1.width > obj2.x &&
        obj1.y < obj2.y + obj2.height &&
        obj1.y + obj1.height > obj2.y
      );
    }
    
    // 玩家被擊中
    function playerHit() {
      gameState.lives--;
      updateUI();
      
      if (gameState.lives <= 0) {
        gameOver();
      } else {
        // 重置玩家位置
        player.x = 100;
        player.y = config.height - 150;
        player.velY = 0;
        player.isJumping = false;
      }
    }
    
    // 遊戲結束
    function gameOver() {
      gameState.isRunning = false;
      
      // 更新最高分
      if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem(config.localStorageKey, gameState.highScore);
        highScoreDisplay.textContent = `最高分: ${gameState.highScore}`;
      }
      
      // 顯示結束畫面
      finalScore.textContent = `你的分數: ${gameState.score}`;
      gameOverScreen.style.display = 'flex';
    }
    
    // 更新UI
    function updateUI() {
      scoreDisplay.textContent = `分數: ${gameState.score}`;
      livesDisplay.textContent = `生命: ${gameState.lives}`;
    }
    
    // 繪製遊戲
    function draw() {
      // 清空畫布
      ctx.clearRect(0, 0, config.width, config.height);
      
      // 繪製背景
      if (images.background.complete) {
        ctx.drawImage(images.background, 0, 0, config.width, config.height);
      } else {
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, config.width, config.height);
        
        // 繪製雲朵
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(100, 80, 30, 0, Math.PI * 2);
        ctx.arc(130, 80, 40, 0, Math.PI * 2);
        ctx.arc(170, 80, 30, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(400, 120, 30, 0, Math.PI * 2);
        ctx.arc(430, 120, 40, 0, Math.PI * 2);
        ctx.arc(470, 120, 30, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // 繪製平台
      platforms.forEach(platform => {
        if (images.platform.complete) {
          ctx.drawImage(images.platform, platform.x, platform.y, platform.width, platform.height);
        } else {
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        }
      });
      
      // 繪製星星
      stars.forEach(star => {
        if (!star.collected) {
          if (images.star.complete) {
            ctx.drawImage(images.star, star.x, star.y, star.width, star.height);
          } else {
            ctx.fillStyle = 'gold';
            drawStar(ctx, star.x + star.width/2, star.y + star.height/2, 5, star.width/2, star.height/4);
          }
        }
      });
      
      // 繪製金幣
      coins.forEach(coin => {
        if (!coin.collected) {
          if (images.coin.complete) {
            ctx.drawImage(images.coin, coin.x, coin.y, coin.width, coin.height);
          } else {
            ctx.fillStyle = 'gold';
            ctx.beginPath();
            ctx.arc(coin.x + coin.width/2, coin.y + coin.height/2, coin.width/2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
      
      // 繪製敵人
      enemies.forEach(enemy => {
        if (images.enemy.complete) {
          ctx.drawImage(images.enemy, enemy.x, enemy.y, enemy.width, enemy.height);
        } else {
          ctx.fillStyle = 'red';
          ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        }
      });
      
      // 繪製玩家
      if (images.player.complete) {
        // 根據方向決定是否翻轉圖片
        if (player.direction === 'left') {
          ctx.save();
          ctx.translate(player.x + player.width, player.y);
          ctx.scale(-1, 1);
          ctx.drawImage(images.player, 0, 0, player.width, player.height);
          ctx.restore();
        } else {
          ctx.drawImage(images.player, player.x, player.y, player.width, player.height);
        }
      } else {
        ctx.fillStyle = 'blue';
        ctx.fillRect(player.x, player.y, player.width, player.height);
      }
    }
    
    // 繪製星星形狀
    function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
      let rot = Math.PI / 2 * 3;
      let x = cx;
      let y = cy;
      let step = Math.PI / spikes;
      
      ctx.beginPath();
      ctx.moveTo(cx, cy - outerRadius);
      
      for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;
        
        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
      }
      
      ctx.lineTo(cx, cy - outerRadius);
      ctx.closePath();
      ctx.fill();
    }
    
    // 初始化遊戲
    initGame();
  </script>
</body>
</html>